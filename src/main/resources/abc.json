[
  { "area": "Core Java", "topic": "Data Types & Variables", "subtopic": "Primitive types (int, long, float, double, boolean, char, byte, short)", "priority": "must-know", "notes": "Foundation for all Java code; understanding memory allocation", "status": "pending" },
  { "area": "Core Java", "topic": "Data Types & Variables", "subtopic": "Wrapper classes (Integer, Long, Double, etc.)", "priority": "must-know", "notes": "Required for Collections, autoboxing/unboxing in interviews", "status": "pending" },
  { "area": "Core Java", "topic": "Data Types & Variables", "subtopic": "Type casting (implicit vs explicit)", "priority": "must-know", "notes": "Common in data manipulation and API responses", "status": "pending" },
  { "area": "Core Java", "topic": "Data Types & Variables", "subtopic": "Variable scope (local, instance, static)", "priority": "must-know", "notes": "Critical for understanding memory and thread safety", "status": "pending" },
  { "area": "Core Java", "topic": "Data Types & Variables", "subtopic": "Final, static, transient, volatile keywords", "priority": "must-know", "notes": "volatile asked in concurrency interviews; transient in serialization", "status": "pending" },
  { "area": "Core Java", "topic": "Strings", "subtopic": "String immutability and String pool", "priority": "must-know", "notes": "Classic interview question; memory optimization concept", "status": "pending" },
  { "area": "Core Java", "topic": "Strings", "subtopic": "String vs StringBuilder vs StringBuffer", "priority": "must-know", "notes": "Performance question in every interview", "status": "pending" },
  { "area": "Core Java", "topic": "Strings", "subtopic": "String methods (substring, split, replace, trim, etc.)", "priority": "must-know", "notes": "Used in coding rounds and string manipulation", "status": "pending" },
  { "area": "Core Java", "topic": "Strings", "subtopic": "String formatting (String.format(), formatted())", "priority": "good-to-know", "notes": "Useful for logging and API responses", "status": "pending" },
  { "area": "Core Java", "topic": "Strings", "subtopic": "Regular expressions (Pattern, Matcher)", "priority": "good-to-know", "notes": "Used in validation, parsing logs, data processing", "status": "pending" },

  { "area": "Core Java", "topic": "Operators & Control Flow", "subtopic": "Arithmetic, relational, logical, bitwise operators", "priority": "must-know", "notes": "Basic programming; bitwise asked in algorithmic interviews", "status": "pending" },
  { "area": "Core Java", "topic": "Operators & Control Flow", "subtopic": "if-else, switch-case (including switch expressions Java 14+)", "priority": "must-know", "notes": "Control flow basics; modern switch expressions trending", "status": "pending" },
  { "area": "Core Java", "topic": "Operators & Control Flow", "subtopic": "Loops (for, while, do-while, enhanced for)", "priority": "must-know", "notes": "Essential for coding problems", "status": "pending" },
  { "area": "Core Java", "topic": "Operators & Control Flow", "subtopic": "Break, continue, return statements", "priority": "must-know", "notes": "Loop control in algorithms", "status": "pending" },
  { "area": "Core Java", "topic": "Operators & Control Flow", "subtopic": "Ternary operator", "priority": "must-know", "notes": "Code readability and concise expressions", "status": "pending" },

  { "area": "Core Java", "topic": "Exception Handling", "subtopic": "try-catch-finally blocks", "priority": "must-know", "notes": "Fundamental error handling in production code", "status": "pending" },
  { "area": "Core Java", "topic": "Exception Handling", "subtopic": "Checked vs Unchecked exceptions", "priority": "must-know", "notes": "Design decision in custom exceptions; commonly asked", "status": "pending" },
  { "area": "Core Java", "topic": "Exception Handling", "subtopic": "throw vs throws keyword", "priority": "must-know", "notes": "Method signatures and exception propagation", "status": "pending" },
  { "area": "Core Java", "topic": "Exception Handling", "subtopic": "Custom exceptions", "priority": "must-know", "notes": "Used extensively in Spring Boot for business logic errors", "status": "pending" },
  { "area": "Core Java", "topic": "Exception Handling", "subtopic": "try-with-resources (AutoCloseable)", "priority": "must-know", "notes": "Resource management; file/DB connections in interviews", "status": "pending" },
  { "area": "Core Java", "topic": "Exception Handling", "subtopic": "Exception chaining and multi-catch", "priority": "good-to-know", "notes": "Cleaner error handling in complex scenarios", "status": "pending" },
  { "area": "Core Java", "topic": "Exception Handling", "subtopic": "Best practices (catch specific exceptions, logging)", "priority": "must-know", "notes": "Production code quality; asked in system design rounds", "status": "pending" },

  { "area": "Core Java", "topic": "Object-Oriented Programming", "subtopic": "Classes and Objects", "priority": "must-know", "notes": "OOP foundation", "status": "pending" },
  { "area": "Core Java", "topic": "Object-Oriented Programming", "subtopic": "Constructors (default, parameterized, copy)", "priority": "must-know", "notes": "Object initialization; constructor chaining in interviews", "status": "pending" },
  { "area": "Core Java", "topic": "Object-Oriented Programming", "subtopic": "this and super keywords", "priority": "must-know", "notes": "Reference resolution and inheritance", "status": "pending" },
  { "area": "Core Java", "topic": "Object-Oriented Programming", "subtopic": "Encapsulation (private fields, getters/setters)", "priority": "must-know", "notes": "Core OOP principle; data hiding", "status": "pending" },
  { "area": "Core Java", "topic": "Object-Oriented Programming", "subtopic": "Inheritance (single, multilevel, hierarchical)", "priority": "must-know", "notes": "Code reuse; interview favorite", "status": "pending" },
  { "area": "Core Java", "topic": "Object-Oriented Programming", "subtopic": "Method overriding (runtime polymorphism)", "priority": "must-know", "notes": "Dynamic binding; @Override annotation", "status": "pending" },
  { "area": "Core Java", "topic": "Object-Oriented Programming", "subtopic": "Method overloading (compile-time polymorphism)", "priority": "must-know", "notes": "Flexibility in method signatures", "status": "pending" },
  { "area": "Core Java", "topic": "Object-Oriented Programming", "subtopic": "Abstract classes vs Interfaces", "priority": "must-know", "notes": "Design choice question in every OOP interview", "status": "pending" },
  { "area": "Core Java", "topic": "Object-Oriented Programming", "subtopic": "Interface default and static methods (Java 8+)", "priority": "must-know", "notes": "Modern Java features; backward compatibility", "status": "pending" },
  { "area": "Core Java", "topic": "Object-Oriented Programming", "subtopic": "Composition vs Inheritance", "priority": "must-know", "notes": "Design principle; favor composition over inheritance", "status": "pending" },
  { "area": "Core Java", "topic": "Object-Oriented Programming", "subtopic": "Access modifiers (public, private, protected, default)", "priority": "must-know", "notes": "Visibility control; package-level access", "status": "pending" },
  { "area": "Core Java", "topic": "Object-Oriented Programming", "subtopic": "Static members (variables, methods, blocks)", "priority": "must-know", "notes": "Class-level vs instance-level; initialization order", "status": "pending" },
  { "area": "Core Java", "topic": "Object-Oriented Programming", "subtopic": "Inner classes (member, static, local, anonymous)", "priority": "good-to-know", "notes": "Used in event handling, callbacks; less common in modern code", "status": "pending" },

  { "area": "Core Java", "topic": "Object Class Methods", "subtopic": "equals() and hashCode() contract", "priority": "must-know", "notes": "Critical for HashMap, HashSet; common interview trap", "status": "pending" },
  { "area": "Core Java", "topic": "Object Class Methods", "subtopic": "toString() method", "priority": "must-know", "notes": "Debugging and logging; overriding for custom objects", "status": "pending" },
  { "area": "Core Java", "topic": "Object Class Methods", "subtopic": "clone() and Cloneable interface", "priority": "good-to-know", "notes": "Shallow vs deep copy; less used in modern Java", "status": "pending" },
  { "area": "Core Java", "topic": "Object Class Methods", "subtopic": "finalize() method", "priority": "postpone", "notes": "Deprecated in Java 9; use try-with-resources instead", "status": "pending" },

  { "area": "Core Java", "topic": "Collections Framework", "subtopic": "Collection hierarchy (Collection, List, Set, Queue)", "priority": "must-know", "notes": "Foundation for data structures; asked in every interview", "status": "pending" },
  { "area": "Core Java", "topic": "Collections Framework", "subtopic": "List: ArrayList vs LinkedList", "priority": "must-know", "notes": "Performance characteristics; when to use which", "status": "pending" },
  { "area": "Core Java", "topic": "Collections Framework", "subtopic": "Set: HashSet vs LinkedHashSet vs TreeSet", "priority": "must-know", "notes": "Uniqueness, ordering, and sorting; use cases", "status": "pending" },
  { "area": "Core Java", "topic": "Collections Framework", "subtopic": "Map: HashMap vs LinkedHashMap vs TreeMap", "priority": "must-know", "notes": "Key-value storage; ordering and sorting strategies", "status": "pending" },
  { "area": "Core Java", "topic": "Collections Framework", "subtopic": "HashMap internals (buckets, hashing, collisions)", "priority": "must-know", "notes": "Most asked data structure interview question", "status": "pending" },
  { "area": "Core Java", "topic": "Collections Framework", "subtopic": "ConcurrentHashMap vs Hashtable vs Collections.synchronizedMap", "priority": "must-know", "notes": "Thread-safe collections; concurrency interviews", "status": "pending" },
  { "area": "Core Java", "topic": "Collections Framework", "subtopic": "Queue: PriorityQueue, Deque, ArrayDeque", "priority": "good-to-know", "notes": "Used in algorithms; BFS, DFS implementations", "status": "pending" },
  { "area": "Core Java", "topic": "Collections Framework", "subtopic": "Collections utility class (sort, reverse, binarySearch)", "priority": "must-know", "notes": "Common operations; reduces boilerplate", "status": "pending" },
  { "area": "Core Java", "topic": "Collections Framework", "subtopic": "Comparable vs Comparator", "priority": "must-know", "notes": "Custom sorting; frequently asked in coding rounds", "status": "pending" },
  { "area": "Core Java", "topic": "Collections Framework", "subtopic": "Iterator vs ListIterator vs forEach", "priority": "must-know", "notes": "Collection traversal; fail-fast behavior", "status": "pending" },
  { "area": "Core Java", "topic": "Collections Framework", "subtopic": "fail-fast vs fail-safe iterators", "priority": "good-to-know", "notes": "ConcurrentModificationException; concurrent collections", "status": "pending" },
  { "area": "Core Java", "topic": "Collections Framework", "subtopic": "WeakHashMap, IdentityHashMap", "priority": "postpone", "notes": "Rare use cases; cache implementations", "status": "pending" },

  { "area": "Core Java", "topic": "Generics", "subtopic": "Generic classes and methods", "priority": "must-know", "notes": "Type safety; reusable code", "status": "pending" },
  { "area": "Core Java", "topic": "Generics", "subtopic": "Bounded type parameters (extends, super)", "priority": "must-know", "notes": "Flexible generic constraints", "status": "pending" },
  { "area": "Core Java", "topic": "Generics", "subtopic": "Wildcards (?, extends, super)", "priority": "must-know", "notes": "PECS principle; commonly asked in interviews", "status": "pending" },
  { "area": "Core Java", "topic": "Generics", "subtopic": "Type erasure", "priority": "good-to-know", "notes": "Understanding runtime behavior of generics", "status": "pending" },

  { "area": "Core Java", "topic": "Lambda & Functional Programming", "subtopic": "Lambda expressions syntax", "priority": "must-know", "notes": "Modern Java style; concise code", "status": "pending" },
  { "area": "Core Java", "topic": "Lambda & Functional Programming", "subtopic": "Functional interfaces (@FunctionalInterface)", "priority": "must-know", "notes": "Single abstract method; lambda targets", "status": "pending" },
  { "area": "Core Java", "topic": "Lambda & Functional Programming", "subtopic": "Predicate, Function, Consumer, Supplier interfaces", "priority": "must-know", "notes": "Used extensively in Streams and modern APIs", "status": "pending" },
  { "area": "Core Java", "topic": "Lambda & Functional Programming", "subtopic": "Method references (::)", "priority": "must-know", "notes": "Cleaner syntax than lambdas", "status": "pending" },
  { "area": "Core Java", "topic": "Lambda & Functional Programming", "subtopic": "Constructor references", "priority": "good-to-know", "notes": "Factory patterns with method references", "status": "pending" },

  { "area": "Core Java", "topic": "Stream API", "subtopic": "Stream creation (of, generate, iterate)", "priority": "must-know", "notes": "Foundation for functional-style operations", "status": "pending" },
  { "area": "Core Java", "topic": "Stream API", "subtopic": "Intermediate operations (filter, map, flatMap, distinct, sorted)", "priority": "must-know", "notes": "Core transformations; coding interview staple", "status": "pending" },
  { "area": "Core Java", "topic": "Stream API", "subtopic": "Terminal operations (forEach, collect, reduce, count)", "priority": "must-know", "notes": "Triggering stream pipeline execution", "status": "pending" },
  { "area": "Core Java", "topic": "Stream API", "subtopic": "Collectors (toList, toSet, toMap, groupingBy, partitioningBy)", "priority": "must-know", "notes": "Data aggregation; frequently used in business logic", "status": "pending" },
  { "area": "Core Java", "topic": "Stream API", "subtopic": "Optional class (ofNullable, orElse, orElseThrow)", "priority": "must-know", "notes": "Null-safety; modern approach to handle nulls", "status": "pending" },
  { "area": "Core Java", "topic": "Stream API", "subtopic": "Parallel streams", "priority": "good-to-know", "notes": "Performance optimization; understand when to use", "status": "pending" },
  { "area": "Core Java", "topic": "Stream API", "subtopic": "Stream vs Collection differences", "priority": "must-know", "notes": "Lazy evaluation, one-time use; conceptual understanding", "status": "pending" },

  { "area": "Core Java", "topic": "Date & Time API", "subtopic": "LocalDate, LocalTime, LocalDateTime", "priority": "must-know", "notes": "Replacing old Date/Calendar; immutable classes", "status": "pending" },
  { "area": "Core Java", "topic": "Date & Time API", "subtopic": "ZonedDateTime, Instant", "priority": "must-know", "notes": "Timezone handling in distributed systems", "status": "pending" },
  { "area": "Core Java", "topic": "Date & Time API", "subtopic": "Period and Duration", "priority": "good-to-know", "notes": "Date arithmetic and calculations", "status": "pending" },
  { "area": "Core Java", "topic": "Date & Time API", "subtopic": "DateTimeFormatter", "priority": "must-know", "notes": "Parsing and formatting dates for APIs", "status": "pending" },

  { "area": "Core Java", "topic": "File I/O & NIO", "subtopic": "File, Path, Paths classes", "priority": "must-know", "notes": "File operations in backend services", "status": "pending" },
  { "area": "Core Java", "topic": "File I/O & NIO", "subtopic": "BufferedReader, BufferedWriter", "priority": "must-know", "notes": "Efficient file reading/writing", "status": "pending" },
  { "area": "Core Java", "topic": "File I/O & NIO", "subtopic": "Files utility class (readAllLines, write, copy, move)", "priority": "must-know", "notes": "Modern file operations; cleaner API", "status": "pending" },
  { "area": "Core Java", "topic": "File I/O & NIO", "subtopic": "Streams for file operations (Files.lines)", "priority": "good-to-know", "notes": "Memory-efficient large file processing", "status": "pending" },
  { "area": "Core Java", "topic": "File I/O & NIO", "subtopic": "Serialization and Deserialization", "priority": "good-to-know", "notes": "Object persistence; less common with JSON APIs", "status": "pending" },

  { "area": "Advanced Java", "topic": "Multithreading & Concurrency", "subtopic": "Thread class vs Runnable vs Callable", "priority": "must-know", "notes": "Thread creation; return values with Callable", "status": "pending" },
  { "area": "Advanced Java", "topic": "Multithreading & Concurrency", "subtopic": "Thread lifecycle (NEW, RUNNABLE, BLOCKED, WAITING, TERMINATED)", "priority": "must-know", "notes": "Understanding thread states for debugging", "status": "pending" },
  { "area": "Advanced Java", "topic": "Multithreading & Concurrency", "subtopic": "synchronized keyword (method and block level)", "priority": "must-know", "notes": "Basic thread safety; classic interview topic", "status": "pending" },
  { "area": "Advanced Java", "topic": "Multithreading & Concurrency", "subtopic": "wait(), notify(), notifyAll()", "priority": "must-know", "notes": "Inter-thread communication; producer-consumer problem", "status": "pending" },
  { "area": "Advanced Java", "topic": "Multithreading & Concurrency", "subtopic": "Locks (ReentrantLock, ReadWriteLock)", "priority": "must-know", "notes": "Advanced locking; better control than synchronized", "status": "pending" },
  { "area": "Advanced Java", "topic": "Multithreading & Concurrency", "subtopic": "volatile keyword", "priority": "must-know", "notes": "Visibility guarantee; lightweight synchronization", "status": "pending" },
  { "area": "Advanced Java", "topic": "Multithreading & Concurrency", "subtopic": "Atomic classes (AtomicInteger, AtomicBoolean)", "priority": "must-know", "notes": "Lock-free thread-safe operations", "status": "pending" },
  { "area": "Advanced Java", "topic": "Multithreading & Concurrency", "subtopic": "ThreadLocal", "priority": "must-know", "notes": "Thread-confined data; used in security contexts", "status": "pending" },
  { "area": "Advanced Java", "topic": "Multithreading & Concurrency", "subtopic": "Executor framework (ExecutorService, ScheduledExecutorService)", "priority": "must-know", "notes": "Thread pool management; async task execution", "status": "pending" },
  { "area": "Advanced Java", "topic": "Multithreading & Concurrency", "subtopic": "Future and CompletableFuture", "priority": "must-know", "notes": "Async programming; non-blocking operations", "status": "pending" },
  { "area": "Advanced Java", "topic": "Multithreading & Concurrency", "subtopic": "CountDownLatch, CyclicBarrier, Semaphore", "priority": "good-to-know", "notes": "Coordination primitives; synchronization scenarios", "status": "pending" },
  { "area": "Advanced Java", "topic": "Multithreading & Concurrency", "subtopic": "Phaser", "priority": "postpone", "notes": "Advanced synchronization; rarely used", "status": "pending" },
  { "area": "Advanced Java", "topic": "Multithreading & Concurrency", "subtopic": "ForkJoinPool and parallel processing", "priority": "good-to-know", "notes": "Divide-and-conquer parallelism", "status": "pending" },
  { "area": "Advanced Java", "topic": "Multithreading & Concurrency", "subtopic": "Thread safety and immutability", "priority": "must-know", "notes": "Design principle for concurrent code", "status": "pending" },
  { "area": "Advanced Java", "topic": "Multithreading & Concurrency", "subtopic": "Deadlock, livelock, race condition", "priority": "must-know", "notes": "Common concurrency problems; debugging scenarios", "status": "pending" },

  { "area": "Advanced Java", "topic": "Memory Management & JVM", "subtopic": "JVM architecture (ClassLoader, Runtime Data area, Execution Engine)", "priority": "good-to-know", "notes": "Understanding Java execution model", "status": "pending" },
  { "area": "Advanced Java", "topic": "Memory Management & JVM", "subtopic": "Heap vs Stack memory", "priority": "must-know", "notes": "Memory allocation; object vs primitive storage", "status": "pending" },
  { "area": "Advanced Java", "topic": "Memory Management & JVM", "subtopic": "Garbage Collection basics", "priority": "must-know", "notes": "Automatic memory management", "status": "pending" },
  { "area": "Advanced Java", "topic": "Memory Management & JVM", "subtopic": "GC algorithms (Serial, Parallel, CMS, G1, ZGC)", "priority": "good-to-know", "notes": "Performance tuning; production troubleshooting", "status": "pending" },
  { "area": "Advanced Java", "topic": "Memory Management & JVM", "subtopic": "Memory leaks and detection", "priority": "must-know", "notes": "Production issues; heap dump analysis", "status": "pending" },
  { "area": "Advanced Java", "topic": "Memory Management & JVM", "subtopic": "OutOfMemoryError types and solutions", "priority": "must-know", "notes": "Common production errors", "status": "pending" },
  { "area": "Advanced Java", "topic": "Memory Management & JVM", "subtopic": "JVM tuning parameters (-Xms, -Xmx, -XX options)", "priority": "good-to-know", "notes": "Performance optimization in production", "status": "pending" },
  { "area": "Advanced Java", "topic": "Memory Management & JVM", "subtopic": "Strong, Weak, Soft, Phantom references", "priority": "postpone", "notes": "Advanced memory management; rare use cases", "status": "pending" },

  { "area": "Advanced Java", "topic": "Reflection & Annotations", "subtopic": "Reflection API (Class, Method, Field objects)", "priority": "good-to-know", "notes": "Used by frameworks like Spring; understanding DI", "status": "pending" },
  { "area": "Advanced Java", "topic": "Reflection & Annotations", "subtopic": "Creating and using custom annotations", "priority": "good-to-know", "notes": "Framework development; validation annotations", "status": "pending" },
  { "area": "Advanced Java", "topic": "Reflection & Annotations", "subtopic": "Annotation processing", "priority": "postpone", "notes": "Advanced topic build-time code generation", "status": "pending" },
  { "area": "Advanced Java", "topic": "Reflection & Annotations", "subtopic": "Built-in annotations (@Override, @Deprecated, @SuppressWarnings)", "priority": "must-know", "notes": "Code quality and compiler hints", "status": "pending" },

  { "area": "Advanced Java", "topic": "Design Patterns", "subtopic": "Creational: Singleton, Factory, Abstract Factory, Builder", "priority": "must-know", "notes": "Object creation patterns; very common in interviews", "status": "pending" },
  { "area": "Advanced Java", "topic": "Design Patterns", "subtopic": "Structural: Adapter, Decorator, Proxy, Facade", "priority": "must-know", "notes": "Object composition; Spring uses Proxy heavily", "status": "pending" },
  { "area": "Advanced Java", "topic": "Design Patterns", "subtopic": "Behavioral: Observer, Strategy, Template Method, Command", "priority": "must-know", "notes": "Behavior encapsulation; Spring events use Observer", "status": "pending" },
  { "area": "Advanced Java", "topic": "Design Patterns", "subtopic": "Dependency Injection pattern", "priority": "must-know", "notes": "Core to Spring; inversion of control", "status": "pending" },
  { "area": "Advanced Java", "topic": "Design Patterns", "subtopic": "Chain of Responsibility, State, Visitor", "priority": "good-to-know", "notes": "Advanced patterns; less frequently used", "status": "pending" },

  { "area": "Advanced Java", "topic": "SOLID Principles", "subtopic": "Single Responsibility Principle", "priority": "must-know", "notes": "Class design; maintainability", "status": "pending" },
  { "area": "Advanced Java", "topic": "SOLID Principles", "subtopic": "Open/Closed Principle", "priority": "must-know", "notes": "Extension without modification", "status": "pending" },
  { "area": "Advanced Java", "topic": "SOLID Principles", "subtopic": "Liskov Substitution Principle", "priority": "must-know", "notes": "Inheritance contracts", "status": "pending" },
  { "area": "Advanced Java", "topic": "SOLID Principles", "subtopic": "Interface Segregation Principle", "priority": "must-know", "notes": "Client-specific interfaces", "status": "pending" },
  { "area": "Advanced Java", "topic": "SOLID Principles", "subtopic": "Dependency Inversion Principle", "priority": "must-know", "notes": "Depend on abstractions; foundation of DI", "status": "pending" },


  { "area": "Spring Core", "topic": "IoC Container & DI", "subtopic": "Inversion of Control concept", "priority": "must-know", "notes": "Core Spring philosophy", "status": "pending" },
  { "area": "Spring Core", "topic": "IoC Container & DI", "subtopic": "BeanFactory vs ApplicationContext", "priority": "must-know", "notes": "Container differences; interview question", "status": "pending" },
  { "area": "Spring Core", "topic": "IoC Container & DI", "subtopic": "Dependency Injection types (constructor, setter, field)", "priority": "must-know", "notes": "Best practice is constructor injection", "status": "pending" },
  { "area": "Spring Core", "topic": "IoC Container & DI", "subtopic": "@Autowired, @Inject, @Resource", "priority": "must-know", "notes": "DI annotations; differences and use cases", "status": "pending" },
  { "area": "Spring Core", "topic": "IoC Container & DI", "subtopic": "@Qualifier and @Primary", "priority": "must-know", "notes": "Resolving multiple bean candidates", "status": "pending" },
  { "area": "Spring Core", "topic": "IoC Container & DI", "subtopic": "Constructor vs Setter injection pros/cons", "priority": "must-know", "notes": "Design choice; immutability discussion", "status": "pending" },

  { "area": "Spring Core", "topic": "Bean Lifecycle & Scopes", "subtopic": "Bean scopes (singleton, prototype, request, session)", "priority": "must-know", "notes": "Scope determines bean instance lifecycle", "status": "pending" },
  { "area": "Spring Core", "topic": "Bean Lifecycle & Scopes", "subtopic": "Bean lifecycle callbacks (@PostConstruct, @PreDestroy)", "priority": "must-know", "notes": "Initialization and cleanup logic", "status": "pending" },
  { "area": "Spring Core", "topic": "Bean Lifecycle & Scopes", "subtopic": "InitializingBean, DisposableBean interfaces", "priority": "good-to-know", "notes": "Alternative to annotations; less preferred", "status": "pending" },
  { "area": "Spring Core", "topic": "Bean Lifecycle & Scopes", "subtopic": "BeanPostProcessor", "priority": "good-to-know", "notes": "Custom bean initialization logic", "status": "pending" },
  { "area": "Spring Core", "topic": "Bean Lifecycle & Scopes", "subtopic": "Lazy initialization (@Lazy)", "priority": "must-know", "notes": "Performance optimization; on-demand bean creation", "status": "pending" },

  { "area": "Spring Core", "topic": "Configuration", "subtopic": "Java-based configuration (@Configuration, @Bean)", "priority": "must-know", "notes": "Modern Spring approach; type-safe", "status": "pending" },
  { "area": "Spring Core", "topic": "Configuration", "subtopic": "Component scanning (@ComponentScan)", "priority": "must-know", "notes": "Auto-detection of beans", "status": "pending" },
  { "area": "Spring Core", "topic": "Configuration", "subtopic": "Stereotype annotations (@Component, @Service, @Repository)", "priority": "must-know", "notes": "Semantic bean naming; layer separation", "status": "pending" },
  { "area": "Spring Core", "topic": "Configuration", "subtopic": "XML configuration", "priority": "postpone", "notes": "Legacy approach; rarely used in new projects", "status": "pending" },
  { "area": "Spring Core", "topic": "Configuration", "subtopic": "@PropertySource and Environment", "priority": "must-know", "notes": "External configuration; environment-specific settings", "status": "pending" },
  { "area": "Spring Core", "topic": "Configuration", "subtopic": "@Value annotation", "priority": "must-know", "notes": "Injecting property values; SpEL support", "status": "pending" },
  { "area": "Spring Core", "topic": "Configuration", "subtopic": "Profiles (@Profile)", "priority": "must-know", "notes": "Environment-specific beans (dev, prod)", "status": "pending" },

  { "area": "Spring Core", "topic": "AOP (Aspect Oriented Programming)", "subtopic": "AOP concepts (Aspect, Advice, Pointcut, JoinPoint)", "priority": "must-know", "notes": "Cross-cutting concerns; transaction, logging", "status": "pending" },
  { "area": "Spring Core", "topic": "AOP (Aspect Oriented Programming)", "subtopic": "Advice types (@Before, @After, @Around, @AfterReturning, @AfterThrowing)", "priority": "must-know", "notes": "When aspect logic executes", "status": "pending" },
  { "area": "Spring Core", "topic": "AOP (Aspect Oriented Programming)", "subtopic": "Pointcut expressions", "priority": "must-know", "notes": "Selecting where aspects apply", "status": "pending" },
  { "area": "Spring Core", "topic": "AOP (Aspect Oriented Programming)", "subtopic": "AOP proxy (JDK dynamic proxy vs CGLIB)", "priority": "good-to-know", "notes": "Understanding how Spring implements AOP", "status": "pending" },
  { "area": "Spring Core", "topic": "AOP (Aspect Oriented Programming)", "subtopic": "Common use cases (logging, security, transactions)", "priority": "must-know", "notes": "Real-world AOP applications", "status": "pending" },

  { "area": "Spring Core", "topic": "Spring Events", "subtopic": "ApplicationEvent and @EventListener", "priority": "good-to-know", "notes": "Decoupled communication between components", "status": "pending" },
  { "area": "Spring Core", "topic": "Spring Events", "subtopic": "Synchronous vs Asynchronous events", "priority": "good-to-know", "notes": "Event processing strategies", "status": "pending" },


  { "area": "Spring Boot", "topic": "Spring Boot Basics", "subtopic": "Spring Boot advantages and conventions", "priority": "must-know", "notes": "Opinionated defaults; rapid development", "status": "pending" },
  { "area": "Spring Boot", "topic": "Spring Boot Basics", "subtopic": "@SpringBootApplication annotation", "priority": "must-know", "notes": "Combines @Configuration, @EnableAutoConfiguration, @ComponentScan", "status": "pending" },
  { "area": "Spring Boot", "topic": "Spring Boot Basics", "subtopic": "Auto-configuration mechanism", "priority": "must-know", "notes": "Conditional bean creation; understanding autoconfigure", "status": "pending" },
  { "area": "Spring Boot", "topic": "Spring Boot Basics", "subtopic": "Spring Initializr and project structure", "priority": "must-know", "notes": "Project scaffolding; standard layout", "status": "pending" },
  { "area": "Spring Boot", "topic": "Spring Boot Basics", "subtopic": "application.properties vs application.yml", "priority": "must-know", "notes": "Configuration formats; YAML preferred for readability", "status": "pending" },
  { "area": "Spring Boot", "topic": "Spring Boot Basics", "subtopic": "Profile-specific properties (application-dev.yml)", "priority": "must-know", "notes": "Environment-based configuration", "status": "pending" },
  { "area": "Spring Boot", "topic": "Spring Boot Basics", "subtopic": "CommandLineRunner and ApplicationRunner", "priority": "good-to-know", "notes": "Startup logic execution", "status": "pending" },

  { "area": "Spring Boot", "topic": "REST API Development", "subtopic": "@RestController vs @Controller", "priority": "must-know", "notes": "@RestController = @Controller + @ResponseBody", "status": "pending" },
  { "area": "Spring Boot", "topic": "REST API Development", "subtopic": "HTTP methods (@GetMapping, @PostMapping, @PutMapping, @DeleteMapping, @PatchMapping)", "priority": "must-know", "notes": "RESTful endpoint mapping", "status": "pending" },
  { "area": "Spring Boot", "topic": "REST API Development", "subtopic": "@RequestBody, @PathVariable, @RequestParam", "priority": "must-know", "notes": "Request data extraction", "status": "pending" },
  { "area": "Spring Boot", "topic": "REST API Development", "subtopic": "@RequestHeader and @CookieValue", "priority": "good-to-know", "notes": "Header and cookie extraction", "status": "pending" },
  { "area": "Spring Boot", "topic": "REST API Development", "subtopic": "ResponseEntity and HTTP status codes", "priority": "must-know", "notes": "Controlling response status and headers", "status": "pending" },

  { "area": "Spring Boot", "topic": "Exception Handling & Validation", "subtopic": "@ExceptionHandler and @ControllerAdvice", "priority": "must-know", "notes": "Global exception handling; consistency in error responses", "status": "pending" },
  { "area": "Spring Boot", "topic": "Exception Handling & Validation", "subtopic": "HTTP status codes and problem statement (RFC 7807)", "priority": "must-know", "notes": "RESTful error response standards", "status": "pending" },
  { "area": "Spring Boot", "topic": "Exception Handling & Validation", "subtopic": "@Valid and @Validated annotations", "priority": "must-know", "notes": "Request validation; javax.validation", "status": "pending" },
  { "area": "Spring Boot", "topic": "Exception Handling & Validation", "subtopic": "Custom validators", "priority": "must-know", "notes": "Business logic validation beyond standard constraints", "status": "pending" },
  { "area": "Spring Boot", "topic": "Exception Handling & Validation", "subtopic": "Constraint annotations (@NotNull, @NotEmpty, @Email, etc.)", "priority": "must-know", "notes": "Data integrity; automatic validation", "status": "pending" },
  { "area": "Spring Boot", "topic": "Exception Handling & Validation", "subtopic": "Validation error messages and localization", "priority": "good-to-know", "notes": "User-friendly error feedback", "status": "pending" },

  { "area": "Spring Boot", "topic": "Data Access Layer", "subtopic": "Spring Data JPA integration", "priority": "must-know", "notes": "Repository pattern; CRUD operations", "status": "pending" },
  { "area": "Spring Boot", "topic": "Data Access Layer", "subtopic": "Database configuration (DataSource, connection pooling)", "priority": "must-know", "notes": "HikariCP in Spring Boot; performance tuning", "status": "pending" },
  { "area": "Spring Boot", "topic": "Data Access Layer", "subtopic": "JpaRepository and CrudRepository", "priority": "must-know", "notes": "Built-in query methods; extends chain", "status": "pending" },
  { "area": "Spring Boot", "topic": "Data Access Layer", "subtopic": "Custom repository methods", "priority": "must-know", "notes": "Query method naming conventions", "status": "pending" },
  { "area": "Spring Boot", "topic": "Data Access Layer", "subtopic": "@Query and native queries", "priority": "must-know", "notes": "Custom JPQL and SQL queries", "status": "pending" },

  { "area": "Spring Boot", "topic": "Logging & Monitoring", "subtopic": "Logging frameworks (SLF4J, Logback)", "priority": "must-know", "notes": "Structured logging; dependency abstraction", "status": "pending" },
  { "area": "Spring Boot", "topic": "Logging & Monitoring", "subtopic": "Log levels (DEBUG, INFO, WARN, ERROR, TRACE)", "priority": "must-know", "notes": "Appropriate logging at each level", "status": "pending" },
  { "area": "Spring Boot", "topic": "Logging & Monitoring", "subtopic": "Actuator endpoints (/health, /metrics, /info)", "priority": "must-know", "notes": "Monitoring and observability", "status": "pending" },
  { "area": "Spring Boot", "topic": "Logging & Monitoring", "subtopic": "Custom metrics with Micrometer", "priority": "good-to-know", "notes": "Application-specific monitoring", "status": "pending" },
  { "area": "Spring Boot", "topic": "Logging & Monitoring", "subtopic": "Distributed tracing concepts", "priority": "good-to-know", "notes": "Correlation IDs, tracing across services", "status": "pending" },

  { "area": "Spring Boot", "topic": "Security & Authentication", "subtopic": "Spring Security basics", "priority": "must-know", "notes": "Authentication and authorization framework", "status": "pending" },
  { "area": "Spring Boot", "topic": "Security & Authentication", "subtopic": "JWT token implementation", "priority": "must-know", "notes": "Stateless authentication; standard bearer tokens", "status": "pending" },
  { "area": "Spring Boot", "topic": "Security & Authentication", "subtopic": "OAuth2 and OpenID Connect basics", "priority": "good-to-know", "notes": "Third-party authorization; industry standard", "status": "pending" },
  { "area": "Spring Boot", "topic": "Security & Authentication", "subtopic": "Role-based access control (RBAC)", "priority": "must-know", "notes": "@PreAuthorize, @PostAuthorize annotations", "status": "pending" },
  { "area": "Spring Boot", "topic": "Security & Authentication", "subtopic": "CORS configuration", "priority": "must-know", "notes": "Cross-origin requests in REST APIs", "status": "pending" },
  { "area": "Spring Boot", "topic": "Security & Authentication", "subtopic": "CSRF protection", "priority": "must-know", "notes": "Web security; token-based APIs", "status": "pending" },
  { "area": "Spring Boot", "topic": "Security & Authentication", "subtopic": "Password hashing (BCrypt, Argon2)", "priority": "must-know", "notes": "Secure password storage; never plain text", "status": "pending" },

  { "area": "Spring Boot", "topic": "Testing", "subtopic": "@SpringBootTest and @WebMvcTest", "priority": "must-know", "notes": "Unit and integration testing", "status": "pending" },
  { "area": "Spring Boot", "topic": "Testing", "subtopic": "MockMvc for REST controller testing", "priority": "must-know", "notes": "Testing REST endpoints without server", "status": "pending" },
  { "area": "Spring Boot", "topic": "Testing", "subtopic": "Mockito and test doubles", "priority": "must-know", "notes": "Mocking dependencies in tests", "status": "pending" },
  { "area": "Spring Boot", "topic": "Testing", "subtopic": "@DataJpaTest for repository testing", "priority": "must-know", "notes": "Testing data access layers", "status": "pending" },
  { "area": "Spring Boot", "topic": "Testing", "subtopic": "TestRestTemplate", "priority": "good-to-know", "notes": "Integration testing with real HTTP", "status": "pending" },

  { "area": "Spring Boot", "topic": "Async & Scheduling", "subtopic": "@Async annotation", "priority": "must-know", "notes": "Asynchronous method execution", "status": "pending" },
  { "area": "Spring Boot", "topic": "Async & Scheduling", "subtopic": "@Scheduled annotation", "priority": "must-know", "notes": "Cron jobs and scheduled tasks", "status": "pending" },
  { "area": "Spring Boot", "topic": "Async & Scheduling", "subtopic": "Task scheduling configuration", "priority": "good-to-know", "notes": "ThreadPoolTaskScheduler setup", "status": "pending" },

  { "area": "Spring Boot", "topic": "Caching", "subtopic": "@Cacheable, @CacheEvict, @CachePut", "priority": "must-know", "notes": "Declarative caching; performance optimization", "status": "pending" },
  { "area": "Spring Boot", "topic": "Caching", "subtopic": "Cache providers (Caffeine, Redis)", "priority": "must-know", "notes": "In-memory vs distributed caching", "status": "pending" },
  { "area": "Spring Boot", "topic": "Caching", "subtopic": "Cache invalidation strategies", "priority": "must-know", "notes": "TTL, LRU, manual eviction", "status": "pending" },

  { "area": "Spring Boot", "topic": "Transactional Management", "subtopic": "@Transactional annotation", "priority": "must-know", "notes": "ACID properties; database consistency", "status": "pending" },
  { "area": "Spring Boot", "topic": "Transactional Management", "subtopic": "Propagation levels (REQUIRED, REQUIRES_NEW, NESTED)", "priority": "must-know", "notes": "Transaction boundary control", "status": "pending" },
  { "area": "Spring Boot", "topic": "Transactional Management", "subtopic": "Isolation levels (READ_UNCOMMITTED, READ_COMMITTED, etc.)", "priority": "must-know", "notes": "Concurrency control in transactions", "status": "pending" },
  { "area": "Spring Boot", "topic": "Transactional Management", "subtopic": "Rollback behavior and exceptions", "priority": "must-know", "notes": "Checked vs unchecked exceptions", "status": "pending" },
  { "area": "Spring Boot", "topic": "Transactional Management", "subtopic": "Transaction timeout and read-only mode", "priority": "good-to-know", "notes": "Performance tuning; intent declaration", "status": "pending" },



  { "area": "Spring Data JPA / Hibernate", "topic": "JPA Fundamentals", "subtopic": "Entity class design (@Entity, @Table)", "priority": "must-know", "notes": "ORM mapping; database abstraction", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "JPA Fundamentals", "subtopic": "Primary keys (@Id, @GeneratedValue strategies)", "priority": "must-know", "notes": "AUTO, IDENTITY, SEQUENCE, TABLE strategies", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "JPA Fundamentals", "subtopic": "@Column and field mapping", "priority": "must-know", "notes": "Column properties; nullability, unique constraints", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "JPA Fundamentals", "subtopic": "Embedded objects (@Embeddable)", "priority": "good-to-know", "notes": "Value object composition", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "JPA Fundamentals", "subtopic": "Entity lifecycle (New, Managed, Detached, Removed)", "priority": "must-know", "notes": "Understanding persistence state", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "JPA Fundamentals", "subtopic": "Persistence context and identity management", "priority": "must-know", "notes": "First-level cache; object equality", "status": "pending" },

  { "area": "Spring Data JPA / Hibernate", "topic": "Relationships & Associations", "subtopic": "One-to-Many relationships", "priority": "must-know", "notes": "@OneToMany, @JoinColumn mapping", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Relationships & Associations", "subtopic": "Many-to-One relationships", "priority": "must-know", "notes": "@ManyToOne; foreign key side", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Relationships & Associations", "subtopic": "One-to-One relationships", "priority": "must-know", "notes": "Owning vs non-owning sides", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Relationships & Associations", "subtopic": "Many-to-Many relationships", "priority": "must-know", "notes": "@ManyToMany, join tables", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Relationships & Associations", "subtopic": "Bidirectional vs unidirectional relationships", "priority": "must-know", "notes": "Navigability and synchronization", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Relationships & Associations", "subtopic": "Cascading behavior (CascadeType.PERSIST, MERGE, REMOVE)", "priority": "must-know", "notes": "Automatic state propagation", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Relationships & Associations", "subtopic": "Fetch strategies (LAZY vs EAGER)", "priority": "must-know", "notes": "N+1 problem; query optimization", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Relationships & Associations", "subtopic": "Orphan deletion", "priority": "good-to-know", "notes": "Cleaning up removed associations", "status": "pending" },

  { "area": "Spring Data JPA / Hibernate", "topic": "JPQL & Query Methods", "subtopic": "JPQL syntax and HQL", "priority": "must-know", "notes": "Object-oriented query language", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "JPQL & Query Methods", "subtopic": "Named queries (@NamedQuery)", "priority": "good-to-know", "notes": "Reusable query definitions", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "JPQL & Query Methods", "subtopic": "Native SQL queries", "priority": "must-know", "notes": "Complex queries; database-specific features", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "JPQL & Query Methods", "subtopic": "Query pagination and sorting", "priority": "must-know", "notes": "Pageable interface; large result sets", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "JPQL & Query Methods", "subtopic": "Projections (DTO, interface-based)", "priority": "must-know", "notes": "Selecting specific fields; memory optimization", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "JPQL & Query Methods", "subtopic": "Query method naming conventions", "priority": "must-know", "notes": "Automatic query generation", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "JPQL & Query Methods", "subtopic": "Specification API for dynamic queries", "priority": "must-know", "notes": "Reusable predicates; complex filters", "status": "pending" },

  { "area": "Spring Data JPA / Hibernate", "topic": "Lazy Loading & Proxies", "subtopic": "Proxy mechanism in Hibernate", "priority": "must-know", "notes": "Lazy loading implementation; bytecode enhancement", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Lazy Loading & Proxies", "subtopic": "LazyInitializationException", "priority": "must-know", "notes": "Common error when accessing lazy properties outside session", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Lazy Loading & Proxies", "subtopic": "EntityGraph for query optimization", "priority": "must-know", "notes": "Controlling fetch strategy per query", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Lazy Loading & Proxies", "subtopic": "DISTINCT to handle duplicate results", "priority": "good-to-know", "notes": "Cartesian product in joins", "status": "pending" },

  { "area": "Spring Data JPA / Hibernate", "topic": "Persistence Context Management", "subtopic": "Session and SessionFactory", "priority": "must-know", "notes": "First-level cache; transaction scope", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Persistence Context Management", "subtopic": "EntityManager and EntityManagerFactory", "priority": "must-know", "notes": "JPA abstraction over Hibernate", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Persistence Context Management", "subtopic": "Detached objects and merge()", "priority": "must-know", "notes": "Reattaching objects to session", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Persistence Context Management", "subtopic": "flush() and clear() methods", "priority": "must-know", "notes": "Forcing writes; clearing cache", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Persistence Context Management", "subtopic": "Eviction policies", "priority": "good-to-know", "notes": "Managing cache size", "status": "pending" },

  { "area": "Spring Data JPA / Hibernate", "topic": "Performance Tuning", "subtopic": "Query optimization and EXPLAIN plans", "priority": "must-know", "notes": "Understanding query execution", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Performance Tuning", "subtopic": "Batch processing (batch size configuration)", "priority": "must-know", "notes": "Bulk inserts/updates; reducing round trips", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Performance Tuning", "subtopic": "Second-level cache (EhCache, Redis)", "priority": "must-know", "notes": "Cross-session caching; distributed cache", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Performance Tuning", "subtopic": "Query result caching", "priority": "good-to-know", "notes": "Caching SELECT results", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Performance Tuning", "subtopic": "Connection pooling optimization", "priority": "must-know", "notes": "HikariCP settings; thread pool sizing", "status": "pending" },

  { "area": "Spring Data JPA / Hibernate", "topic": "Inheritance Strategies", "subtopic": "Single table inheritance (@DiscriminatorColumn)", "priority": "must-know", "notes": "Storing hierarchy in one table", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Inheritance Strategies", "subtopic": "Joined table inheritance", "priority": "must-know", "notes": "Normalized schema; per-class tables", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Inheritance Strategies", "subtopic": "Table per class inheritance", "priority": "good-to-know", "notes": "Duplication; less performant", "status": "pending" },
  { "area": "Spring Data JPA / Hibernate", "topic": "Inheritance Strategies", "subtopic": "Choosing appropriate strategy", "priority": "must-know", "notes": "Query complexity vs database normalization trade-offs", "status": "pending" },


  { "area": "Database Fundamentals", "topic": "SQL Basics", "subtopic": "SELECT, INSERT, UPDATE, DELETE (CRUD)", "priority": "must-know", "notes": "Foundation of data manipulation", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "SQL Basics", "subtopic": "WHERE, GROUP BY, HAVING, ORDER BY clauses", "priority": "must-know", "notes": "Filtering, aggregation, sorting", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "SQL Basics", "subtopic": "DISTINCT, LIMIT, OFFSET", "priority": "must-know", "notes": "Unique values; pagination", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "SQL Basics", "subtopic": "Aggregate functions (COUNT, SUM, AVG, MIN, MAX)", "priority": "must-know", "notes": "Data summarization", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "SQL Basics", "subtopic": "String functions (CONCAT, SUBSTRING, LENGTH, UPPER, LOWER)", "priority": "must-know", "notes": "Text manipulation in queries", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "SQL Basics", "subtopic": "Date functions (NOW, DATE_FORMAT, DATEDIFF)", "priority": "must-know", "notes": "Temporal data handling", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "SQL Basics", "subtopic": "CASE statements for conditional logic", "priority": "must-know", "notes": "IF-THEN logic in queries", "status": "pending" },

  { "area": "Database Fundamentals", "topic": "JOINs & Set Operations", "subtopic": "INNER JOIN", "priority": "must-know", "notes": "Common rows in both tables", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "JOINs & Set Operations", "subtopic": "LEFT JOIN (LEFT OUTER JOIN)", "priority": "must-know", "notes": "All rows from left table", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "JOINs & Set Operations", "subtopic": "RIGHT JOIN (RIGHT OUTER JOIN)", "priority": "must-know", "notes": "All rows from right table", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "JOINs & Set Operations", "subtopic": "FULL OUTER JOIN and CROSS JOIN", "priority": "good-to-know", "notes": "Cartesian product; full combinations", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "JOINs & Set Operations", "subtopic": "Self joins", "priority": "must-know", "notes": "Joining table to itself", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "JOINs & Set Operations", "subtopic": "UNION, UNION ALL, INTERSECT, EXCEPT", "priority": "must-know", "notes": "Set operations on query results", "status": "pending" },

  { "area": "Database Fundamentals", "topic": "Subqueries & CTEs", "subtopic": "Scalar subqueries", "priority": "must-know", "notes": "Single-row subqueries in SELECT", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Subqueries & CTEs", "subtopic": "Correlated subqueries", "priority": "must-know", "notes": "Subquery referencing outer query", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Subqueries & CTEs", "subtopic": "IN, EXISTS, ANY, ALL operators", "priority": "must-know", "notes": "Subquery operators for filtering", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Subqueries & CTEs", "subtopic": "Common Table Expressions (CTEs / WITH clause)", "priority": "must-know", "notes": "Readable recursive queries", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Subqueries & CTEs", "subtopic": "Recursive CTEs", "priority": "good-to-know", "notes": "Hierarchical data querying", "status": "pending" },

  { "area": "Database Fundamentals", "topic": "Indexing & Query Optimization", "subtopic": "Index types (Single-column, Composite, Unique)", "priority": "must-know", "notes": "Faster lookups; trade-off with writes", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Indexing & Query Optimization", "subtopic": "CREATE INDEX vs ALTER TABLE", "priority": "must-know", "notes": "Creating indexes on tables", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Indexing & Query Optimization", "subtopic": "Covering indexes", "priority": "must-know", "notes": "Index-only scans without table access", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Indexing & Query Optimization", "subtopic": "Query execution plans (EXPLAIN)", "priority": "must-know", "notes": "Understanding query performance", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Indexing & Query Optimization", "subtopic": "Index selectivity and cardinality", "priority": "must-know", "notes": "Effectiveness of indexes", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Indexing & Query Optimization", "subtopic": "Partial indexes and filtered indexes", "priority": "good-to-know", "notes": "Indexes on subsets of data", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Indexing & Query Optimization", "subtopic": "Statistics and query hints", "priority": "good-to-know", "notes": "Database optimization metadata", "status": "pending" },

  { "area": "Database Fundamentals", "topic": "Transactions & ACID", "subtopic": "ACID properties (Atomicity, Consistency, Isolation, Durability)", "priority": "must-know", "notes": "Database reliability guarantees", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Transactions & ACID", "subtopic": "Transaction isolation levels (READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE)", "priority": "must-know", "notes": "Concurrency control; dirty reads, phantom reads", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Transactions & ACID", "subtopic": "COMMIT and ROLLBACK", "priority": "must-know", "notes": "Transaction finality", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Transactions & ACID", "subtopic": "Deadlock detection and handling", "priority": "must-know", "notes": "Circular wait resolution", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Transactions & ACID", "subtopic": "Lock types (shared, exclusive, intent locks)", "priority": "good-to-know", "notes": "Row-level vs page-level locks", "status": "pending" },

  { "area": "Database Fundamentals", "topic": "Schema Design & Normalization", "subtopic": "Normal forms (1NF, 2NF, 3NF, BCNF)", "priority": "must-know", "notes": "Data redundancy elimination; data integrity", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Schema Design & Normalization", "subtopic": "Denormalization trade-offs", "priority": "must-know", "notes": "Performance vs complexity balance", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Schema Design & Normalization", "subtopic": "Primary key design", "priority": "must-know", "notes": "Natural vs surrogate keys", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Schema Design & Normalization", "subtopic": "Foreign key constraints and referential integrity", "priority": "must-know", "notes": "Data consistency enforcement", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Schema Design & Normalization", "subtopic": "Unique constraints and NULL handling", "priority": "must-know", "notes": "Column-level constraints", "status": "pending" },

  { "area": "Database Fundamentals", "topic": "Views & Stored Objects", "subtopic": "CREATE VIEW and materialized views", "priority": "must-know", "notes": "Virtual tables; pre-computed results", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Views & Stored Objects", "subtopic": "Stored procedures and functions", "priority": "good-to-know", "notes": "Database-side logic; call overhead", "status": "pending" },
  { "area": "Database Fundamentals", "topic": "Views & Stored Objects", "subtopic": "Triggers", "priority": "good-to-know", "notes": "Automatic actions on data changes", "status": "pending" },


  { "area": "Build Tools", "topic": "Maven", "subtopic": "Project Object Model (POM) structure", "priority": "must-know", "notes": "pom.xml basics; Maven philosophy", "status": "pending" },
  { "area": "Build Tools", "topic": "Maven", "subtopic": "Dependencies and dependency management", "priority": "must-know", "notes": "Transitive dependencies; version conflicts", "status": "pending" },
  { "area": "Build Tools", "topic": "Maven", "subtopic": "Maven lifecycle (clean, compile, test, package, deploy)", "priority": "must-know", "notes": "Build phases and goals", "status": "pending" },
  { "area": "Build Tools", "topic": "Maven", "subtopic": "Plugins and plugin configuration", "priority": "must-know", "notes": "Extending Maven functionality", "status": "pending" },
  { "area": "Build Tools", "topic": "Maven", "subtopic": "Profiles for environment-specific builds", "priority": "must-know", "notes": "Conditional configuration", "status": "pending" },
  { "area": "Build Tools", "topic": "Maven", "subtopic": "Multi-module projects", "priority": "must-know", "notes": "Parent-child POM relationships", "status": "pending" },
  { "area": "Build Tools", "topic": "Maven", "subtopic": "Maven repositories and nexus", "priority": "good-to-know", "notes": "Artifact management; private repositories", "status": "pending" },
  { "area": "Build Tools", "topic": "Maven", "subtopic": "BOM (Bill of Materials) for dependency management", "priority": "must-know", "notes": "Consistent version management across projects", "status": "pending" },

  { "area": "Build Tools", "topic": "Gradle", "subtopic": "Build script basics (build.gradle)", "priority": "good-to-know", "notes": "Groovy-based configuration", "status": "pending" },
  { "area": "Build Tools", "topic": "Gradle", "subtopic": "Tasks and task dependencies", "priority": "good-to-know", "notes": "Build execution flow", "status": "pending" },
  { "area": "Build Tools", "topic": "Gradle", "subtopic": "Dependency configuration", "priority": "good-to-know", "notes": "Implementation, testImplementation, etc.", "status": "pending" },
  { "area": "Build Tools", "topic": "Gradle", "subtopic": "Plugins in Gradle", "priority": "good-to-know", "notes": "Extending build capabilities", "status": "pending" },
  { "area": "Build Tools", "topic": "Gradle", "subtopic": "Gradle wrapper", "priority": "good-to-know", "notes": "Version consistency across environments", "status": "pending" },

  { "area": "Build Tools", "topic": "Version Control Best Practices", "subtopic": "Git basics (commit, branch, merge, rebase)", "priority": "must-know", "notes": "Essential for team collaboration", "status": "pending" },
  { "area": "Build Tools", "topic": "Version Control Best Practices", "subtopic": "Branching strategies (Git Flow, Trunk-Based Development)", "priority": "must-know", "notes": "Release and development workflow", "status": "pending" },
  { "area": "Build Tools", "topic": "Version Control Best Practices", "subtopic": ".gitignore for build artifacts", "priority": "must-know", "notes": "Keeping repository clean", "status": "pending" },
  { "area": "Build Tools", "topic": "Version Control Best Practices", "subtopic": "Semantic versioning (MAJOR.MINOR.PATCH)", "priority": "must-know", "notes": "Version numbering conventions", "status": "pending" },


  { "area": "Backend Best Practices", "topic": "REST API Design", "subtopic": "RESTful principles and resource naming", "priority": "must-know", "notes": "Nouns for resources, verbs for HTTP methods", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "REST API Design", "subtopic": "Request/Response format standardization (JSON)", "priority": "must-know", "notes": "Content negotiation; JSON API conventions", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "REST API Design", "subtopic": "Versioning strategies (URL, header, content negotiation)", "priority": "must-know", "notes": "Backward compatibility; API evolution", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "REST API Design", "subtopic": "Pagination, filtering, sorting", "priority": "must-know", "notes": "Large dataset handling", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "REST API Design", "subtopic": "Rate limiting and throttling", "priority": "must-know", "notes": "API protection from abuse", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "REST API Design", "subtopic": "HATEOAS (Hypermedia As The Engine Of Application State)", "priority": "good-to-know", "notes": "Discoverability in REST APIs", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "REST API Design", "subtopic": "OpenAPI / Swagger documentation", "priority": "must-know", "notes": "API specification and interactive docs", "status": "pending" },

  { "area": "Backend Best Practices", "topic": "Error Handling & Logging", "subtopic": "Structured logging (JSON logs)", "priority": "must-know", "notes": "Machine-readable logs for aggregation", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Error Handling & Logging", "subtopic": "Error response structure and codes", "priority": "must-know", "notes": "Consistent error format across APIs", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Error Handling & Logging", "subtopic": "Correlation IDs for tracing", "priority": "must-know", "notes": "End-to-end request tracking", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Error Handling & Logging", "subtopic": "Sensitive data redaction in logs", "priority": "must-know", "notes": "Security and privacy compliance", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Error Handling & Logging", "subtopic": "Log aggregation platforms (ELK, Splunk, Datadog)", "priority": "good-to-know", "notes": "Centralized log management", "status": "pending" },

  { "area": "Backend Best Practices", "topic": "Code Quality & Testing", "subtopic": "Unit testing best practices", "priority": "must-know", "notes": "Isolation, independence, repeatability", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Code Quality & Testing", "subtopic": "Integration testing strategies", "priority": "must-know", "notes": "Testing component interactions", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Code Quality & Testing", "subtopic": "End-to-end (E2E) testing", "priority": "good-to-know", "notes": "Full workflow testing", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Code Quality & Testing", "subtopic": "Test coverage and metrics", "priority": "must-know", "notes": "Code coverage percentage targets", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Code Quality & Testing", "subtopic": "TDD (Test-Driven Development)", "priority": "good-to-know", "notes": "Write tests before code", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Code Quality & Testing", "subtopic": "Code review process", "priority": "must-know", "notes": "Peer review for quality assurance", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Code Quality & Testing", "subtopic": "Static code analysis tools (SonarQube, Checkstyle)", "priority": "good-to-know", "notes": "Automated code quality checks", "status": "pending" },

  { "area": "Backend Best Practices", "topic": "Concurrency & Async Patterns", "subtopic": "Avoiding shared mutable state", "priority": "must-know", "notes": "Thread safety through immutability", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Concurrency & Async Patterns", "subtopic": "Reactive programming principles", "priority": "good-to-know", "notes": "Non-blocking, event-driven", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Concurrency & Async Patterns", "subtopic": "Message queues (RabbitMQ, Kafka, SQS)", "priority": "good-to-know", "notes": "Asynchronous processing; decoupling", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Concurrency & Async Patterns", "subtopic": "Backpressure handling", "priority": "good-to-know", "notes": "Managing producer-consumer speed mismatch", "status": "pending" },

  { "area": "Backend Best Practices", "topic": "Security Best Practices", "subtopic": "Input validation and sanitization", "priority": "must-know", "notes": "Protection against injection attacks", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Security Best Practices", "subtopic": "SQL injection prevention", "priority": "must-know", "notes": "Parameterized queries; no string concatenation", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Security Best Practices", "subtopic": "XSS (Cross-Site Scripting) prevention", "priority": "must-know", "notes": "Output encoding; CSP headers", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Security Best Practices", "subtopic": "OWASP Top 10 vulnerabilities", "priority": "must-know", "notes": "Common attack vectors; mitigation", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Security Best Practices", "subtopic": "Secrets management (environment variables, vaults)", "priority": "must-know", "notes": "API keys, passwords never in code", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Security Best Practices", "subtopic": "HTTPS/TLS for data in transit", "priority": "must-know", "notes": "Encryption; man-in-the-middle prevention", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Security Best Practices", "subtopic": "Data encryption at rest", "priority": "must-know", "notes": "Protecting stored sensitive data", "status": "pending" },

  { "area": "Backend Best Practices", "topic": "Scalability & Performance", "subtopic": "Horizontal vs vertical scaling", "priority": "must-know", "notes": "Adding servers vs increasing resources", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Scalability & Performance", "subtopic": "Load balancing", "priority": "must-know", "notes": "Distributing traffic across servers", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Scalability & Performance", "subtopic": "Database replication and sharding", "priority": "must-know", "notes": "Data redundancy and partitioning", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Scalability & Performance", "subtopic": "Caching strategies (client, server, CDN)", "priority": "must-know", "notes": "Reducing database load", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Scalability & Performance", "subtopic": "Connection pooling", "priority": "must-know", "notes": "Reusing database connections", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Scalability & Performance", "subtopic": "Query optimization and indexing review", "priority": "must-know", "notes": "Bottleneck identification", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Scalability & Performance", "subtopic": "Monitoring and observability stack", "priority": "must-know", "notes": "Metrics, logs, traces (three pillars)", "status": "pending" },

  { "area": "Backend Best Practices", "topic": "Microservices Patterns", "subtopic": "Service boundaries and domain-driven design", "priority": "good-to-know", "notes": "Logical separation of concerns", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Microservices Patterns", "subtopic": "Service discovery", "priority": "good-to-know", "notes": "Dynamic service location (Consul, Eureka)", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Microservices Patterns", "subtopic": "API Gateway pattern", "priority": "good-to-know", "notes": "Single entry point; request routing", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Microservices Patterns", "subtopic": "Circuit breaker pattern", "priority": "good-to-know", "notes": "Fault tolerance; preventing cascading failures", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Microservices Patterns", "subtopic": "Retry and timeout strategies", "priority": "good-to-know", "notes": "Resilience patterns; exponential backoff", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Microservices Patterns", "subtopic": "Saga pattern for distributed transactions", "priority": "good-to-know", "notes": "Maintaining consistency across services", "status": "pending" },

  { "area": "Backend Best Practices", "topic": "DevOps & Deployment", "subtopic": "CI/CD pipelines (Jenkins, GitHub Actions, GitLab CI)", "priority": "must-know", "notes": "Automated build, test, deploy", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "DevOps & Deployment", "subtopic": "Containerization (Docker)", "priority": "must-know", "notes": "Portable application packaging", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "DevOps & Deployment", "subtopic": "Orchestration (Kubernetes basics)", "priority": "good-to-know", "notes": "Container management at scale", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "DevOps & Deployment", "subtopic": "Infrastructure as Code (IaC)", "priority": "good-to-know", "notes": "Terraform, CloudFormation; reproducible infrastructure", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "DevOps & Deployment", "subtopic": "Blue-green deployment", "priority": "good-to-know", "notes": "Zero-downtime releases", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "DevOps & Deployment", "subtopic": "Canary releases and feature flags", "priority": "good-to-know", "notes": "Risk mitigation; gradual rollout", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "DevOps & Deployment", "subtopic": "Configuration management and secrets handling", "priority": "must-know", "notes": "Environment-specific configurations", "status": "pending" },

  { "area": "Backend Best Practices", "topic": "Documentation & Communication", "subtopic": "API documentation (Javadoc, OpenAPI/Swagger)", "priority": "must-know", "notes": "Consumer understanding; contract specification", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Documentation & Communication", "subtopic": "README and architecture documentation", "priority": "must-know", "notes": "Project setup and overview", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Documentation & Communication", "subtopic": "Changelog and release notes", "priority": "must-know", "notes": "Communicating changes to stakeholders", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Documentation & Communication", "subtopic": "ADR (Architecture Decision Records)", "priority": "good-to-know", "notes": "Documenting design decisions", "status": "pending" },

  { "area": "Backend Best Practices", "topic": "Data Management", "subtopic": "Data migration strategies", "priority": "must-know", "notes": "Safe schema changes; minimal downtime", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Data Management", "subtopic": "Backup and disaster recovery", "priority": "must-know", "notes": "Data protection; RTO and RPO", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Data Management", "subtopic": "Data archival and retention policies", "priority": "must-know", "notes": "Compliance and storage optimization", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Data Management", "subtopic": "GDPR and data privacy compliance", "priority": "must-know", "notes": "Right to be forgotten; data anonymization", "status": "pending" },

  { "area": "Backend Best Practices", "topic": "Interview-Specific Deep Dives", "subtopic": "System design fundamentals", "priority": "must-know", "notes": "Scaling applications, handling millions of requests", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Interview-Specific Deep Dives", "subtopic": "Behavioral questions (ownership, conflict resolution)", "priority": "must-know", "notes": "STAR method; demonstrating leadership", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Interview-Specific Deep Dives", "subtopic": "Coding problem-solving strategies", "priority": "must-know", "notes": "Algorithm approach; time-space complexity analysis", "status": "pending" },
  { "area": "Backend Best Practices", "topic": "Interview-Specific Deep Dives", "subtopic": "Live coding exercises and walkthroughs", "priority": "must-know", "notes": "Communicating thought process; handling feedback", "status": "pending" }
]